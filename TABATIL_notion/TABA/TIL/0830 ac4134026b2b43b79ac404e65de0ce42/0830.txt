
PAGE 154-155
버퍼의 처리가 끝날때까지 프로듀서가 기다려야한다
컨스머 입장은 데이터가 들어와서 체우기 전까지 실행해야하는 데이터가 없어서 기다려야한다
버퍼상태를 나타내는 full이라는 변수를 만든다

컨스머의 입장에서는 full이 될때까지 기다린다.
프로듀서의 입장에서는 buffer가 empty가될때까지 기다리고 buffer가 empty되면 처리해준다
메모리 카피 > 실행

condition valiable에서
while loof를 실행하지 않고 기다린다.

condition valuable에 wait를 걸어주고, lock변수를 잡기위해서
mutext_lock을 사용한다

mutex_lock에서 full이 되면
buffer는 0이 된다.

full 외에 여러가지 컨디션을 체크할수 있다.
cond_sigmal(v)를 통해 상태를 깨운다.

*속도차이가 나는 경우: producer / comsummer 속도가 차이날때 (프로듀서가 컨스머보다 100정도 빠를때)
프로듀서가 빠를때 : 여러가지 buffer를 만들어서 consumer가 빨리사용할수있도록한다
컨스머가 빠를때 : 버퍼를 많이 쪼개서 사용한다

실제로는 중간에 여러개의 버퍼를 두고, 여러개의 컨스머와 프로듀서가 쓰는 경우가 많다
최근 GPU, cloud computer에서는 여러개의 버퍼를 두고 여러개의 컨스머와 프로듀서가 협력한다 (비동기 방식으로)


여러스레드를 하다보면 제대로 작동이 되지 않는 경우가 있다 - 그 방법을 시큐어적인 해결방법으로 헤걀할때

시큐어적인 해결방법 : 스핀락 - 스케쥴링에서 제외해서 다른 것들을 사옹 " mutex - 그 방법을 튜레줄러 ?

type을 제대로 사용하지 않아 inteager을 사용해서 나는 에러

실행할때마다 다른 결과가 나오는 경우, 시큐어적으로 해결한다

멀티스레드프로그래밍은 에러가 각기 다르게나오기때문에 디버깅이 어렵다
스레드 -> 디파짓  > 쓰로우 > 크리티컬섹션(더하기/빼기) > 여기에서 vitual_mutex를 걸어보도록 한다
PAGE 159 예시
사용하기위해 초기화를 한다. : 초기화하는 함수 사용 : init()
mutext변수를 하나 선언하고 init함수를 사용 >
엔트리뷰트 값을 null값으로 준다

lock을 number가 100만번 argumet로 들어가서 100만번의 lock을 잡고 푼다.

struct elemet{
    byte buffer[4K]
    int buffer_state
    mutex_lock lock;
    cond_var cv;

}

struct buffer{
    struct element e[1024];
    int p_index , c_index;
    mutex_lock_p_lock,c_lock;
}

PAGE 157
여러개의 컨스머, 프로듀서 , 버퍼를 만들때
버퍼에 인덱스를 붙인다

내가 봐야할 버퍼를 
어떤버퍼에서 lock을 가지고 만들때
동기화할때 오버헤드가 만히든ㄷ.

여러개의 버퍼를 만들고 , 버퍼에 인덱스를 붙인다.
내가 사용해야하는 버퍼를 컨디션 체크하기 위해 컨디션베리어블을 만든다.
컨디션베리어브를 만들기 위해 lock을 만든다버퍼가 다 

컨슈머 도
스레드 100개의 버퍼를쓸수있는버퍼에서 사용한다면
동기화의 버퍼에서 overhaed한다
컨슈머 스레드의 개수와 버퍼의 개수가 동일하다면 lock이 필요없다
컨디션베리어블을 사용하려면 마찬가지로 index lock을 잡아야한다.
lock을 잡고 컨디션을 체크하고 해결


동기화를 자주하게되면 25-30% 비용이 든다.
GPU, 네크워크 프로세싱 등등 여러 스레드를 사용할때
데이터를 자기 데이터로 가져온다음 동기화 오버헤드를 없게 만든다

멀티코어를 하게 되서 멀티스레드를 사용하는 부분이 많이 중요해졌다
GPU환경 : CUDA, ovencl의 경우 병렬 방식으로 사용한다

cpu : 멀티스레드를 기반으로 프로그래밍 - 동기화 , 스키쥴링 기법등을 많이 사용한다

** 프로두서 .컨스머를 만들어보고 , 버퍼를 만들어서 프로그래밍 하는 방법 알아보기 ***

*** FORK (오전수업 - 따로 보충하기) ***

fork하고 exac하여 signal을 보낸다.

signal 예제 보기 : signal OS가 thread에 상황을 알려준다. 예를들어 알람 thrad을 볼 수 있다.

알람 signal : 일정 time이 되면 signal을 보내서 알 수 있게 → 특정 함수를 실행할 수 있다

signal handler 함수를 실행

intervalTimer : 간격을 두고 타임을 signal한다.

timerevent를 매 일정한 동작을 수행한다.

타이머가 호출이되면 시간알람을 os에 보낸다.

* TADA 과제: 프로세스10개에 일정 타이밍을 SIGNAL로 보낸다.

이 과정에서 input/output 또는 다른 옵션들을 추가할 수 있다.

쉘 프로그래밍을 만드는 과정 : 시스템 개발자 / OS게발자가 나와 맞는지를 판단할 수 있다.

fork2예제 :
child 10명을 생성하는 예제 + signal과 합친다.

알람을 받으면 알람handler를 실행,
차일드 프로세스를 실행
부모프로세스에서 차일드프로세스의 id를 배열에 저장한다
차일드쪽에서는 시작하면 sig_user_one을 실행
위 시그널을 받으면 차일드를 실행

부모 프로세스가 차일드프로세스를 받도록 기다리고, 알람이 오면 알람 핸들러에서 차일드에게 시그널을 받을 수 있게한다.


PAGE 171
컴퓨터주소는 byte단위로 생성한다.
byte는 8bit로 묶어서 1byte로 사용한다

8bit마다 고유한 address를 사용할수 있다.

inteager형 자료는 4byte를 쓴다고하면
4byte씩 묶어서 데이터를 사용한다

address path에는 위 부분이 여러가지가 있다.
물리적으로 메모리가 주소 끝에 32bit컴퓨터는 32bit주소만큼 받을수있다. 32bit가 0으로 바뀌면 0이 32개, 1로 바뀌면 1111로 바꿀수있다. 16진수로 변경된다
처음부터 끝까지 사이즈가 2의 32승의 갯수에  대한 주소를 나타낼 수 있다. : 4기가 가 가능하다 40억개 보다 살짝 많은

이렇게 4기가로 되어있는 프로세스가 많이 돌아갈때
virtual memory에서는 어떻게하면 효율적으로 사용할 수 있을지 계산한다

intel은 세그미테이션과 페이지테이션을 사용
64bit로 넘어오면서 세그미테이션은 할 수 없고 페이징 기법만 가능하다

323bit에서 64bit로 늘어나면 두배로 늘어나는 것이 아니다. 32bit에서 33bit로 넘어오는 부분이 2배 들어나는것 , 거듭제곱꼴로 되기때문에

intel은 최고프로세스에서는 48bit 나 57bit까지 가능하다
기가바이트 - 페러바이트 -테파바이트 ???

엑세스할수있는 데이터크기가 물리적으로 엄청나게 커진다.
하지만 물리적으로 엄청난 데이터가 꼭 필요하지는 않는다.
이
주소공간은 엄청 큰데 사용공간은 적어서 가비지 공간 (사용하지 않는 공간)이 많아졌다

멀티 레벨 페이징 > 최적화를 많이 한다

프로펄페이지 ???

버츄얼 > 1.맵핑한다. (물리적으로는 하나밖에 없는데 논리적으로는 여러개 있는게끔 보이는 기술)
한번 맵핑해서 인다이렉션을 한다
인다이렉션을 하면 성능상 오버헤드가 커진다


2. 로직화하게 만든다. 

물리메모리 그대로 사용할것 같지만 트렉젝션으로 넘어간다

code작업이 필요할때 : 가능하면 슬라이드에 
fork 예제/thread예제
ㄷ

