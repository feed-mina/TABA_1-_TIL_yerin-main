# 0901 TIL 1차

TLB 는 바이트 단위로 저장한다. 사이즈가 굉장히 큰편이다. 메모리 사이즈보다는 작지만 그럼에도 큰편이다.
엔트리갯수가 100개 ? 몇개 안돼

![0200 0000 : first_inode 1키로바이트는 16진수를 사용하면  0x400 , 2진수 100 0000 0000 : 0이 총 10개 400은 2의 10승 - 첫번째 1키로바이트는 3f0까지 된다. 그 뒤로는 inode가 된다. inode는 32바이트 , 한줄에 16바이트, 두줄에 32바이트](0901%20TIL%201%E1%84%8E%E1%85%A1%20496cecfb02d44a6f83195ddde04cdb6c/Untitled.png)

0200 0000 : first_inode 1키로바이트는 16진수를 사용하면  0x400 , 2진수 100 0000 0000 : 0이 총 10개 400은 2의 10승 - 첫번째 1키로바이트는 3f0까지 된다. 그 뒤로는 inode가 된다. inode는 32바이트 , 한줄에 16바이트, 두줄에 32바이트

0000450 0000 0000 0000 0100 0200 0300 000 0000

디스크 블록 0번 1번 2번 3번블록에 가면 루트파일의 정보가 있다

파일1에 넘버가 적혀있다.

0x400 1KB superblock

0x2000 8kb indes array

0x21 까지 1kb , 0x21 ~ 0x22또 1kb 용량

0x40000  4mb datablocks 1kb 0x4088

루트디렉토리 : 파일 이름 / 00002050 file_1

디렉토리 엔트리 처음에 넘버가 나오고 그다음에 이름이 나온다

숫자 이름, 숫자, 이름

이름은 00002040 

00002050 

00002040 : file_1

번호를 끝에서 읽어서 파일 넘버는 3번이다.

[hex](0901%20TIL%201%E1%84%8E%E1%85%A1%20496cecfb02d44a6f83195ddde04cdb6c/hex%203bd7f7ba8fc243158ca8d1dd8f82f9e0.md)

TLB사이즈와 캐쉬를 할때 TLB엔트리가 왜이렇게 작지? 이유는 엔트리하나에 64바이트이기 때문에
4키로바이트 영억을 엔트리 하나로 할 수 있다
엔트리 수를 줄여놓은 이유 : 엔트리 하나가 용량이 크기 때문에

사용자가 쓰는 address 는 모두 VMaddress
PM address에 second level ,
pap에 나머지 옵션을 붙이면 피지컬 address

translation을 할때 맨 먼처 쳐다보는건 PLB
PLB가 있으면 physicadcl address
없으면 한번 더 과정을 한다

physical addres는 cash data를 가져온다.

리드는 콜드미스를 부른다.
라이트는 무조건 읽을필요가 없다. 메모리 데이터를 언젠가 나중에 디스크에 저장하면 된다.
ㅣㄺ은데이터를 가지고 할 경우 동기적으로
쓰기는 모든 데이터를 discript에 하기 전에 비동기 쓰기 작업이 이루어져있다.
PAGE 32
dma는 direct memory access를 의미한다.

cpu 데이터 처리라고 하면 레지던스사이즈 한번에 32,64바이트로 한다
기가바이트 cpu를 멈추고, 다른 장치도 멈추고
Bus에서 데이터를 사용하지 않는 공간을 모아서 사용하는 방법을
DMA라고 한다

DMA : 내가 읽을 데이터를 가져왔는데 cpu캐시에는 쳐다보지 않을 수 있다.
이 동기화를 os가 맞춰야 한다
DMA가 overwrite할때 , 메모리 데이터를 한다 ?

페이지 데이터의 엔트리가 캐쉬가 반응하는지 안하는지를 비트필드한다
없으면 캐쉬가 반응하도록 설정한다

PAGE 36

파일시스템 크게 두가지
하나 디렉토리 구조
둘 인덱스 구조

디렉토리구조와 인덱스 구조로 구분해있다

파일을 저장소에 저장하고 어떤파일인지 구분하는 소프트웨어 : 파일 시스템
이름을 붙이고 이름을 붙여서 데이터를 구분하고 어디에 저장하는지

디렉토리 구조 :  흔히 폴더랑 비슷하지만 상세하게는 오늘 배운다
인덱스 구조 : 파일이 실제로 어디에 저장되어있는지

사용자가 데이터를 저장하는데
데이터와 meta-data를  분리되서 파일이 이루어진다.
파일의 위치, 파일 사이즈 , 읽기 가능한지 / 쓰기 가능한지 등등이 메타데이터이다
데이터를 접근하기 위해 설명하는 데이터 : 메타데이터이다

디렉토리 구조 , 파일 인덱스 구조 : 모두 메타데이터이다

파일 이름을 가지고 파일 number을 찾는다 : 디렉토리 구조
파일 number을 가지고 storage block을 찾는다 : index structre

파일 open -> 이름을 가지고 파일에 해당하는 파일 number를 찾는다. : open의 연산과정
프로세스가 실제가 open한 파일 데이터를 가지고 있다. read / write , sync등을 할 수 있다.

Direcotries : os에서 최근에 folder을 쓰기도 한다.
사전의미 - 전화번호부 , 목록이라고 나온다
디렉토리도 결국 파일이다. 해당하는 디렉토리에 있는 파일의 이름, 파일의 번호가 적혀져있다.
파일의 리스트가 같은 계층에 있는 목록을 볼 수 있다.

계층적 구조로 되어 있따. - 한 디렉토리 안에 다른 디렉토리를 만들 수 있다.
디렉토리 파릴이 또 있다면 하위 디렉토리에 또 다른 디렉토리 정보를 볼 수 있다

디렉토리 entry : 여러개가 들어있다.

엔트리는 파일과 디렉토리로 구분이 가능하다
엔트리는 이름, attribute, id, file number을 가지고 있다.
중요한 attribute는 중요한 자료구조로 따로 때논 attribute도 있다.

disk operation system : 파일시스템이 dos를 하게 할수있다
fat - 파일 annotation table의 약자
디렉토리 파일에다 추가적ㅈ인 attribute를 전부 넣어놓았다

파일 : 저장소 (저장소에 이름을 붙여넣은것)'
data와 metadata가 들어있다. metadata는
디렉토리는 사람을 위해서 존재한다.
file id, filenumber을 가지고 os는 파일여부를 판단한다.
metadata - 파일의 소유자 , accesss-writer을 구분을 가지고 있다.
file이 어디를 읽고 있는지 도 메타데이터(open된 파일의 position)

FAT : 테이블형태
디스크 오퍼레이션 시스템 :
하드디스크를 가운데 동그랗게 생각해서 , 플랙/섹터/디스크로 구분한다.
1문에 n번 돌리는 디스크 : nrpm이라고 한다.
요즘 하드웨어는 논리적으로 일렬로 되어있따고 가정한후 제일 밖의 제일 끝에 있는 데이터를 보여준다.

tract-sector로 바꾼다.
controller로 인해서 01,2,3,4 등 index로 이어져있는 저장장치가 이어져있다.

테이블의 갯수가 나머지 뒤 데이터의 블록에 저장한 것과 동일하다
1:1 mapping이 되어야 한다.

디텍토리 - 파일이름을 가지고 번호를 찾는다.
그 번호를 찾으면 hello.word filed의 디렉토리에서 찾게 되고, filenumber에 의해 찾는 범위가 달라진다.

링크드리스트 형식으로 데이터가 한블록 이상되면 그 다음 데가 어디에 들어있는지 데이터가 적혀져있다.

1. 파일 오픈 -> 2. 디렉토리 파일넘버
fat : 링크드 리스트 형식으ㄹ 되어있다 ***

File은 disk block을 묵여있ㄱ 각 데이터를 block list 시작이 첫번째 노드가 된다.

dist에서 안쓰는 영역을
FAT에서

FAT 블록단위로 쪼개져 사용이 되면 파일들 읽기 쓰기를 마구잡이로 하면
기존의 사용하고 있는 영역들이 있어서 그 기 존들의 영역을 버리고 새로운 경우에 쓰는 경우가 많았으나 (자투리 공간이 많아짐)
디스크` 정리 알고리즘 **유틸리티

Free영역을 한곳에 모아주고 s나머지도 한곳에 모아준다.
31
파일시스템 자체가 복자바지는 않다.

FAT는 제일 처음에 부티앟ㄹ때 FAT내용을 메모리에서 가져온다.
포렌식의 경우 : 데이터의 블록을 직접 부르기도 한다.

단점 :::

링크드리스트 형태로 되어있어 링크드 리스트를 따라가면서 파일을 읽어야=하는데
시퀀설을 할 수 가 없다.

시퀀설을 쪼개져있으니 불편하다

프리리스트가 리스트형태로 되어있어서

피팅 알고리즘의 효율이 좋지 않다.
큰파일 access를 하게되면 list 트리버스 해야하는데 전부하가에 버퍼링이 걸린다.

리스트 만들때 동작 가능하게 하고 실제로 처음 사용하는 부분이 FAT이다.

PAGE47
디렉토리는 파일 이름, number, 이렇게 생겼다.
FAT에서는 여기서 추가적인 정보도 넣을 수 있게 생겼다.
시작하는 파일이 대게는 정해져 있다. (root파일)

Link 와 Direcotries -> 상대적으로 덜 중요

File access 만 만들고 디렉토리 관련된건 안한거같은데.. 심볼릭 링크도 안한거같구..

리눅스에서 특히 많이 사용되는데
링크파일 : 이름은 다르지만 똑같은 파일을 만든다.
내용은 같은데 이름은 다른 방법

파일이 어디에 저장되어있는지알수 있는 방법 :
index structrre를 똑같이 가리키게 하는 방법(1) hard-link
파일의 이름은 다르지만 번호가 똑같아요(2) soft-link

a파일에 대한 path를 가지고 100번 파일이라고 기억할수있고
b파일에 대한 path를 가지고 100번 파일이라고 할 수 있게 한다

Big Fat Security holes :
index와 똑같은 number를 가리키기 때문에 index number를 훼손하면 Security holes도 망가진다