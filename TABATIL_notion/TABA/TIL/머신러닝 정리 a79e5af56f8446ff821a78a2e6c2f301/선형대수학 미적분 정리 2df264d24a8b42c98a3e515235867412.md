# 선형대수학 / 미적분 정리

### 알고리즘 서택과 코드최적화를 하려면 최소한의 수학지식은 알고 있어야 한다.

### 선형 대수학 : 행렬

행렬은 많은 데이터를 묶을 수 있다는 장점과 계산도 효율적인 장점이 있다. 

### 미적분학 : 최적화를 할때 사용한다

성능이 얼마나 별로인지 평가하는 함수의 그래프에서 성능이 제일 좋은 부분은 가장 최소값이라는것을 알수 있다.

![Untitled](%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%83%E1%85%A2%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%86%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202df264d24a8b42c98a3e515235867412/Untitled.png)

### 통계 : 데이터에서 큰 흐름 파악 → 예측에서 사용

### 확률 : 생존할확률 70% → 생존자라고 예측 , 생존할 확률 20% → 사망자라고 예측

> 머신러닝을 위한 수학
> 

### 일차식 표기법

![Untitled](%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%83%E1%85%A2%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%86%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202df264d24a8b42c98a3e515235867412/Untitled%201.png)

### 행렬과 백터

![Untitled](%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%83%E1%85%A2%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%86%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202df264d24a8b42c98a3e515235867412/Untitled%202.png)

### 3 X 4 행렬 표기 방법 : 행 X 열 차원이다 라고 한다.

![Untitled](%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%83%E1%85%A2%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%86%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202df264d24a8b42c98a3e515235867412/Untitled%203.png)

### 백터 : 행이 하나거나 열이 하나인 행렬

![Untitled](%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%83%E1%85%A2%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%86%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202df264d24a8b42c98a3e515235867412/Untitled%204.png)

### 백터는 무조건 열이 하나거나 행이 하나밖에 없기 때문에 a는 5차원의 열백터 b는 4차원의 행백터라고도 한다.

![Untitled](%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%83%E1%85%A2%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%86%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202df264d24a8b42c98a3e515235867412/Untitled%205.png)

### 행렬은 대문자, 백터는 소문자로 주로 표시한다.

### numpy 행렬 사용

```python
import numpy as np
np.array(
[[1,-1,2],
[3,2,2],
[4,1,2],
[7,5,6]])

```

```python
import numpy as np
np.array(
[[1,-1,2],
[3,2,2],
[4,1,2],
[7,5,6]])

A[0][2] => 2
# A[행-가로][열-세로]
c = np.random.rend(3,5)
D = np.zeros((2,4)))
```

```python
import numpy as np

# 1: 행렬 A를 정의해보세요
A = np.array([
    [0, 1, -1],
    [1, 2, 3],
    [2, 1, 0],
    [-1, 2, -4]
])

# 2: 행렬 B를 정의해보세요
B = np.array([
    [0, 2],
    [1, 1],
    [-1, -2]
])

print(A)
print(B)
print(A[1][1])  # 3: 여기서 A의 2행 2열 원소에 접근해보세요
print(A[3][0])  # 4: 여기서 A의 4행 1열 원소에 접근해보세요
```

### 스칼라곱

 선형대수학에서는 행렬의 원소가 아닌 일반 수를 **스칼라**
라고 하는데요. 그러면 i는 스칼라라고 할 수 있겠죠? 행렬 A를 스칼라 i와 곱하는 것이기 때문에 스칼라곱이라고 하는 겁니다.

![Untitled](%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%83%E1%85%A2%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%86%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202df264d24a8b42c98a3e515235867412/Untitled%206.png)

### 

![Untitled](%E1%84%89%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%83%E1%85%A2%E1%84%89%E1%85%AE%E1%84%92%E1%85%A1%E1%86%A8%20%E1%84%86%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202df264d24a8b42c98a3e515235867412/Untitled%207.png)

우리는 A의 행들과 B의 열들을 곱해야 하잖아요? 그럴려면 A의 행에 있는 원소 수랑 B의 열에 있는 원소 수랑 같아야겠죠? 따라서 A의 열 수와 B의 행 수가 딱 맞아 떨어져야 두 행렬을 곱할 수 있는 겁니다.

조금 더 일반화해서 설명드리자면, m x n인 행렬 A와 n x p인 행렬 B를 곱한다고 가정합시다. 우선 A의 열 수와 B의 행 수가 딱 맞아 떨어지기 때문에 두 행렬을 곱할 수 있습니다. 그리고 곱하면 A의 행 수와 B의 열 수를 따서 m x p 행렬이 결과로 나올 것입니다.

### m x n 행렬 (A)과 n x p 행렬(B)

A의 열과 B의 행의 수가 같기 때문에 곱셈 가능 !

### mxp행렬 AB

### AB =! BA

### ****요소별 곱하기****

```python
import numpy as np

A = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
])

B = np.array([
    [0, 1, 2],
    [2, 0, 1],
    [1, 2, 0]
])

A * B
```

###