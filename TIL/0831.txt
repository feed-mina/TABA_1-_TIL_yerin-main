### kill 프로그램 : processs에 시그널을 보낸다. kill [option] 을 줄 수 있다. sig kill -s 옵션을 주면서 할 수 있다. 일반적으로 다른 사람의 프로그래밍을 kill 하면 안된다. sudo 를 통해서 관리자 권한을 통해 준다. 관리하는 작업을 실무적으로 필요하다.

### top 명령어 : 실행하는 프로그래밍을 보여준다. htop

오전수업

### 실제 메모리를 사용하는 것이 아니라 랩핑해서 사용한다. address tranction and paging

### paging 은 작은 사이즈의 랩핑을 여러가지 만들어서 실제

 

### 4키로 단위로 가능하다 . 주소 공간을 4키로 단위로 잘라서 랩핑한다. 랩핑테이블 : 실제로 페이지 표현된 주소 실제로 페이지 랩핑된 정보가 들어가있다.

### 페이지 정보가 전혀 없더라도 pfn 을 통해서 알 수 있다. index를 통해 바로 찾을 수 있기 때문에 page from number을 통해 알 수 있다.

### 1. 랩핑 개수를 줄이면 좋겠다.

### 2. 프로세스 커널의 공간과 라이브러리 사용하는 공간은 똑같은 공간일 경우가 많다. 일번,이번,삼번 프로세스 마다 커널의 버츄얼메트릭스 공간이 필요한데 내용이 같다. 반복되기 때문에 줄이면 좋겠다.

### 페이지 프로젝텍이션 세컨레벌의 페이지 시작구조 : 큰 단위의 랩핑을 하고싶을때, invalidid 랩핑을 하고 싶을때 예를 들어 램핑 테이플 사이즈가 엄청나게 작아진다.

실제로 어떻게 줄여질까?

작은 맵핑 하나, 나머지는 쓸데 없는 랩핑, 
작은 테이블 하나가 필요, 백만개의 랩핑을 할 필요가 없이 큰 랩핑 테이블에서 나머지 테이블을 null로 만든다.

주소를 세부 공간으로 나눈다.

4키로 바이트에서의 주소 : page index를
작은 레핑 : L2 table index
큰 랩핑 : L1 table index

TTBR : 제일 큰 랩핑의 시작주소를 가리킨다
4k byte : 0 -11 page-index 2의 10승
L2 table index : 12 =20 까지
L1 table index :21부터  - 31  2의 10승

상위 10개가 큰단위의 랩핑의 개수

second table의 index 를 가지고 second table의 second 주소부터 얼만큼 떨어져 있는지 를 계산 할 수 있다.

45PAGE

피지컬메모리에 값이 이렇게 들어있다. 가상주소 0-9로 어떻게 할지
PMem[Addr/4] = addr + 0 x 1:0000
addr 에 0을 넣으면 값은 1:0000이 된다.
address 0 
4번 주소에 들어있는 값은 address/4 
배열의 index에 들어있는 값을 각각 구할 수 있다. :: PMem is 4 bytes array

4byte단위로 쭉 들어있는 PMEM인데 , TTBR은 0이 들어가있따. 0x1234:56778 을 가상조회하면 그 값은 무엇일까?



1. single level

page number 0x12345
VA 0x12345 
index는 0x12345 의 address는 x4하면 나온다.
idex / addr /value
0 / 0 / 10000
2 / 1 / 10004
3 / 2 / 10008
3 / 3 /10006  ( 왜 10016이 아닐까 ? )

0x12345 / 0x12345 / 58014 
    / 0X58014678 0X58104 678
PA (피지컬 어드레스) : 678
psm : x0814
pA : 0x58014 678
value : 0x58014679 (0X58014 678 에 1을 더한다 ) 

2. 2-lavel paging 
(12/8/12)

bin/bash : 메모리의 내용이 들어가있다. 
0000 -1111 까지 16진수

12bit / 8bit / 12bit
3자리 2자리 3자리


TTBR 0부터 시작
index가 16진수로 

1-level 끝난후

2-level paging이 시작한다

Disk Swapping
실제로 우리가 사용할 수 있는 메모리는 4기가 바이트가 넘어가게 된다.
이미 4기가 바이트가 넘어간 것을 볼 수 있다.
stream data를 받아서 stream으로 올린다음 버리고 올린다음 버리는 과정으로 메모리를 아끼였다.

32비트에서 36비트로 증가시키자.
프로세스 단위로 보면 multi-data 수십개의 데이터를 다루는 프로세스가 나왔다.
2-level, 3-level , 4-level 방식으로 올라갔다.

스토리지 사이즈가 기하급수적으로 증가하였다.
메모리의 공간이 상대적으로 부족해지는 상황이 등장하였다. -> disk swapping 이 나온 이유

디스크 메모리 내용을 교차한다
메모리에 부족한 공간을 디스크에서 잠깐씩 빌려서 쓰게 된다.


PROVICE BACKING STORE fOR VAS ***


내가 가지고 있는 프로세스를 초기화하고, 프로세스가 초기화 하지 않으면 exit full 
프로세스가 사용했던 메모리를 통해 작동을 한다.

메모레 엑세스가 시작하면
데이터가 있는경우에 데이터를 사용한다
데이터가 없다면 page fault를 한다

실제로 메모리를 할당하는 과정에 오래걸린다.
User-level에서 시작하는 주소만 
해당하는 영역에 맵핑 하는 부분이 없다 ( 비어있을때) cpu가 해당영역을 할 수 없다
cpu가 메모리 엑세스를 할 수 없기 때문에 예외처리가 발생한다 :: page fault를 한다
pagefault를 하면 OS makes new mapping 한다


진짜로 메모리가 다 떨어지면
계속 사용하는 부분들은 cpu에서 쓸 수 있게 둔다.
사용하지 않는 부분들은 LRU 를 한다 

하드웨어는 cpu 캐쉬를 LRU알고리즘을 쓰고
OS working set 를 한다
같이 사용하는 메모리들을 working set 알고리즘으로 사용할지/ 안할지 유무 판단



Thrasihing : 갑자기 컴퓨터가 느려지는 상황
계속 swap out 될때 
전체 working set 사이즈가 물리 메모리보다 커질때
어떤 메모리를 access하든 disk에 가져와야하는데
disk에 가져오려면 빈공간이 필요하다

완전 끝까지 쓰지 못하도록 막는다 - 미리 swap out을 시킨다

PLB 자료구조 
CPU 내부에서 가지고 있는 자료구조

1. 바이트단위로 하나하나씩 데이터를 복사할 수 있다.
2. 데이터를 통째로 맵핑해서 복사할 수 있다. : VM

fork하게 되면 page table을 복사하면 어떤 현상이 일어나는가?
page table 만 우선 복사한 후 사용하다가 
데이트가 변경될때 복사가 시작한다.

